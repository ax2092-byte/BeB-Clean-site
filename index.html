<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Admin — B&B Clean</title>
    <link rel="icon" type="image/png" href="../favicon.png">
    <style>
      /* Campo "Codice casa" in sola lettura (visibile) */
      .bb-readonly { background:#f6f7f9; color:#555; pointer-events:none; }

      /* Autocomplete custom */
      .bb-ac-panel {
        position: absolute; z-index: 99999; min-width: 240px; max-width: 520px;
        max-height: 240px; overflow: auto; background: #fff; border: 1px solid #ddd;
        border-radius: .5rem; box-shadow: 0 10px 22px rgba(0,0,0,.08);
        font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      .bb-ac-item { padding: .5rem .75rem; cursor: pointer; }
      .bb-ac-item:hover, .bb-ac-item.active { background: #f2f4f7; }
      .bb-ac-empty { padding: .5rem .75rem; color: #666; }
      .bb-ac-spinner { padding: .5rem .75rem; color: #666; font-style: italic; }

      .bb-inline { display:inline-flex; gap:.5rem; align-items:center; width:100%; }
      .bb-copy { padding:.35rem .6rem; border:1px solid #ccc; border-radius:.4rem; background:#fff; cursor:pointer; }
    </style>
  </head>
  <body>
    <!-- Decap CMS -->
    <script src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"></script>

    <!-- Netlify Identity (login/signup) -->
    <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        if (!window.netlifyIdentity) return;
        window.netlifyIdentity.init();
        var hash = window.location.hash || '';
        if (hash.includes('invite_token') || hash.includes('confirmation_token')) {
          window.netlifyIdentity.open('signup');
        }
        window.netlifyIdentity.on('login',  () => window.location.reload());
        window.netlifyIdentity.on('signup', () => window.location.reload());
      });
    </script>
    <button id="idBtn" style="position:fixed;right:16px;bottom:16px;padding:.6rem 1rem;border:1px solid #ddd;border-radius:.4rem;background:#fff;cursor:pointer;z-index:9999;">
      Accedi / Registrati
    </button>
    <script>document.getElementById('idBtn').onclick=()=>window.netlifyIdentity&&window.netlifyIdentity.open();</script>

    <!-- Script principale -->
    <script>
      (function () {
        // ================== UTILITÀ BASE ==================
        const PREFIX = 'BB';
        const MONTH = { A:1,B:2,C:3,D:4,E:5,H:6,L:7,M:8,P:9,R:10,S:11,T:12 };
        const ODD = { '0':1,'1':0,'2':5,'3':7,'4':9,'5':13,'6':15,'7':17,'8':19,'9':21,
          A:1,B:0,C:5,D:7,E:9,F:13,G:15,H:17,I:19,J:21,K:2,L:4,M:18,N:20,O:11,P:3,Q:6,R:8,S:12,T:14,U:16,V:10,W:22,X:25,Y:24,Z:23 };
        const EVEN = { '0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,
          A:0,B:1,C:2,D:3,E:4,F:5,G:6,H:7,I:8,J:9,K:10,L:11,M:12,N:13,O:14,P:15,Q:16,R:17,S:18,T:19,U:20,V:21,W:22,X:23,Y:24,Z:25 };

        function norm(s){return (s||'').toString().normalize('NFD').replace(/[\u0300-\u036f]/g,'').replace(/[^A-Za-z0-9]/g,'').toUpperCase();}
        function fnv1a(str){let h=0x811c9dc5>>>0;for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=(h+(h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24))>>>0;}return h>>>0;}
        function parseDMY(dmy){if(!/^\d{2}\/\d{2}\/\d{4}$/.test(dmy||''))return null;const d=+dmy.slice(0,2),m=+dmy.slice(3,5),y=+dmy.slice(6,10);if(m<1||m>12||d<1||d>31)return null;return {d,m,y};}
        function cfChecksum(cf15){let s=0;for(let i=0;i<15;i++){const c=cf15[i];if(!c)return null;s+=((i%2)===0?ODD[c]:EVEN[c]);}return String.fromCharCode((s%26)+65);}
        function validateCF(cf,dmy,gender){
          const out={valid:false,message:""};
          if(!cf||!/^[A-Z0-9]{16}$/i.test(cf)){out.message="Formato CF non valido (16 caratteri).";return out;}
          cf=cf.toUpperCase();
          const expected=cfChecksum(cf.slice(0,15)); if(!expected||expected!==cf[15]){out.message="Carattere di controllo CF non valido.";return out;}
          const p=parseDMY(dmy); if(!p||!gender){out.message="Inserisci data (dd/mm/yyyy) e sesso.";return out;}
          const yy=String(p.y).slice(2,4), cfYY=cf.slice(6,8), cfM=cf[8], cfDD=+cf.slice(9,11);
          if(cfYY!==yy){out.message="CF non coincide con anno.";return out;}
          if(MONTH[cfM]!==p.m){out.message="CF non coincide con mese.";return out;}
          const dd=(gender==='F')?(p.d+40):p.d; if(cfDD!==dd){out.message="CF non coincide con giorno/sesso.";return out;}
          out.valid=true; return out;
        }
        function buildHouseCode(p){
          const nZip=norm(p.zip).slice(0,5).padEnd(5,'0');
          const nCity=norm(p.city).slice(0,3).padEnd(3,'X');
          const base=[norm(p.region),norm(p.zip),norm(p.city),norm(p.street),norm(p.number),norm(p.owner_cf)].join('|');
          const hash5=fnv1a(base).toString(36).toUpperCase().slice(0,5).padStart(5,'0');
          return `${PREFIX}-${nZip}-${nCity}-${hash5}`;
        }

        // Trova input/select per etichetta, ma **all’interno** di un contenitore (riga) se passato
        function getInputByLabel(labelText, root=document){
          const labels=[...root.querySelectorAll('label')];
          const lab=labels.find(l=>l.textContent && l.textContent.trim().toLowerCase().includes(labelText.toLowerCase()));
          if(!lab) return null;
          const wrap=lab.closest('[class*="ControlContainer"]')||lab.parentElement;
          return wrap ? (wrap.querySelector('input,select')||null) : null;
        }

        // Scova il "contenitore riga" della casa corrente (risale finché trova un blocco con Codice casa)
        function findRowRoot(fromEl){
          let p = fromEl;
          while (p && p !== document.body) {
            if (getInputByLabel('Codice casa', p)) return p;
            p = p.parentElement;
          }
          // fallback: tutta la pagina
          return document;
        }

        // Imposta valore compatibile con React/Decap (anche per <select>)
        function setReactValue(el, value){
          if (!el) return;
          if (el.nodeName === 'SELECT') {
            const setter = Object.getOwnPropertyDescriptor(HTMLSelectElement.prototype, 'value').set;
            setter.call(el, value);
            el.dispatchEvent(new Event('change', { bubbles: true }));
          } else {
            const setter = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value').set;
            setter.call(el, value);
            el.dispatchEvent(new Event('input', { bubbles: true }));
          }
        }

        function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; }

        // ================== AUTOCOMPLETE CON CACHE E ABORT ==================
        const cityCache   = new Map(); // key: region|q  -> string[]
        const streetCache = new Map(); // key: city|q    -> string[]

        function createPanel(){ const p=document.createElement('div'); p.className='bb-ac-panel'; p.style.display='none'; document.body.appendChild(p); return p; }
        function positionPanel(panel, input){
          const r=input.getBoundingClientRect();
          panel.style.left = (window.scrollX + r.left) + 'px';
          panel.style.top  = (window.scrollY + r.bottom + 4) + 'px';
          panel.style.minWidth = r.width + 'px';
          panel.style.display='block';
        }
        function fillPanel(panel, items, onPick){
          panel.innerHTML='';
          if (!items || !items.length){ const d=document.createElement('div'); d.className='bb-ac-empty'; d.textContent='Nessun risultato'; panel.appendChild(d); return; }
          items.forEach(v=>{
            const it=document.createElement('div'); it.className='bb-ac-item'; it.textContent=v;
            it.onmousedown=(e)=>{ e.preventDefault(); onPick(v); panel.style.display='none'; };
            panel.appendChild(it);
          });
        }
        function showSpinner(panel){ panel.innerHTML='<div class="bb-ac-spinner">Sto cercando…</div>'; }

        async function fetchCities(q, region, signal){
          if (!q || q.length < 2) return []; // evita richieste inutili
          const key=(region||'')+'|'+q.toLowerCase();
          if (cityCache.has(key)) return cityCache.get(key);

          const url=`https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&accept-language=it&countrycodes=it&limit=12&q=${encodeURIComponent(q)}`;
          try{
            const r=await fetch(url, { signal });
            const js=await r.json();
            const allowed=new Set(['city','town','village','hamlet','municipality']);
            const out=[];
            for(const it of js){
              const city=it.address.city||it.address.town||it.address.village||it.address.hamlet||it.address.municipality;
              const reg =it.address.state||it.address.region;
              if (allowed.has(it.type) && city){
                // filtro soft: prima quelle nella stessa regione
                const score = (region && reg && reg.toLowerCase().includes(region.toLowerCase())) ? 0 : 1;
                out.push({city, score});
              }
            }
            out.sort((a,b)=>a.score-b.score);
            const names=[...new Set(out.map(o=>o.city))].slice(0,12);
            cityCache.set(key, names); // cache anche se vuoto -> evita re-loop
            return names;
          }catch(e){
            cityCache.set(key, []);   // cache vuota per evitare loop
            return [];
          }
        }

        async function fetchStreets(q, city, signal){
          if (!q || q.length < 2 || !city) return [];
          const key=(city||'')+'|'+q.toLowerCase();
          if (streetCache.has(key)) return streetCache.get(key);

          const url=`https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&accept-language=it&countrycodes=it&limit=12&q=${encodeURIComponent(q+', '+city+', Italia')}`;
          try{
            const r=await fetch(url, { signal });
            const js=await r.json();
            const out=[];
            for(const it of js){
              const road=it.address.road||it.address.pedestrian||it.address.footway||it.address.path||it.address.cycleway||'';
              if (road) out.push(road);
            }
            const names=[...new Set(out)].slice(0,12);
            streetCache.set(key, names);
            return names;
          }catch(e){
            streetCache.set(key, []);
            return [];
          }
        }

        function attachAutocomplete(input, getParams, onPick){
          if (!input) return;
          if (input._bbAc) return;  // già collegato
          input._bbAc = { panel: createPanel(), ctrl: null, lastQ: null };

          const run = debounce(async ()=>{
            const q=input.value.trim();
            const { type, region, city } = getParams();

            // Se stessa query di prima -> non rifare
            if (input._bbAc.lastQ === q) { 
              input._bbAc.panel.style.display = 'block';
              positionPanel(input._bbAc.panel, input);
              return;
            }
            input._bbAc.lastQ = q;

            // cancella richiesta precedente
            if (input._bbAc.ctrl) input._bbAc.ctrl.abort();
            const ctrl = new AbortController(); input._bbAc.ctrl = ctrl;

            positionPanel(input._bbAc.panel, input);
            showSpinner(input._bbAc.panel);

            let items=[];
            if (type==='city')   items = await fetchCities(q, region, ctrl.signal);
            if (type==='street') items = await fetchStreets(q, city,   ctrl.signal);

            // se l'utente ha digitato altro nel frattempo, esci
            if (ctrl.signal.aborted || input.value.trim() !== q) return;

            fillPanel(input._bbAc.panel, items, (val)=> onPick(val) );
          }, 280);

          input.addEventListener('input', ()=>{ positionPanel(input._bbAc.panel, input); run(); });
          input.addEventListener('focus', ()=>{ positionPanel(input._bbAc.panel, input); run(); });
          input.addEventListener('keydown', (e)=>{ if (e.key==='Escape'){ input._bbAc.panel.style.display='none'; }});
          document.addEventListener('click', (e)=>{ if (!input._bbAc.panel.contains(e.target) && e.target!==input) input._bbAc.panel.style.display='none'; });
        }

        // ================== MASCHERA DATA ==================
        function attachBirthMask(root){
          const el = getInputByLabel('Data di nascita', root);
          if (!el || el._bbMasked) return;
          el._bbMasked = true;
          el.placeholder='gg/mm/aaaa';
          const mask = (v)=>{
            v = (v||'').replace(/[^\d]/g,'').slice(0,8);
            if (v.length>=5) return v.slice(0,2)+'/'+v.slice(2,4)+'/'+v.slice(4);
            if (v.length>=3) return v.slice(0,2)+'/'+v.slice(2);
            return v;
          };
          el.addEventListener('input', ()=>{
            const m = mask(el.value);
            if (el.value !== m) setReactValue(el, m);
          });
          el.addEventListener('blur', ()=>{
            const m = mask(el.value);
            if (el.value !== m) setReactValue(el, m);
          });
          el.addEventListener('paste', (e)=>{
            e.preventDefault();
            const t=(e.clipboardData||window.clipboardData).getData('text')||'';
            setReactValue(el, mask(t));
          });
        }

        // ================== BLOCCO CAMPO CODICE ==================
        function lockCodeField(root){
          const el = getInputByLabel('Codice casa', root);
          if (!el || el._bbLocked) return;
          el._bbLocked = true;
          el.readOnly = true;
          el.setAttribute('aria-readonly','true');
          el.classList.add('bb-readonly');
          el.addEventListener('keydown', (e)=>{
            const ok=['Tab','Shift','ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End'];
            if(!e.ctrlKey && !e.metaKey && !ok.includes(e.key)) e.preventDefault();
          });
          el.addEventListener('beforeinput', (e)=> e.preventDefault());
          el.addEventListener('paste', (e)=> e.preventDefault());

          // bottone copia
          const parent = el.parentElement;
          if (parent && !parent.querySelector('.bb-copy')){
            const wrap = document.createElement('div'); wrap.className='bb-inline';
            parent.insertBefore(wrap, el);
            wrap.appendChild(el);
            const btn=document.createElement('button'); btn.type='button'; btn.className='bb-copy'; btn.textContent='Copia';
            btn.onclick=()=>{ el.select(); document.execCommand('copy'); btn.textContent='Copiato!'; setTimeout(()=>btn.textContent='Copia',1200); };
            wrap.appendChild(btn);
          }
        }

        // ================== GENERAZIONE CODICE (PER-RIGA) ==================
        function updateCodeForRow(root){
          const region = getInputByLabel('Regione', root)?.value || '';
          const city   = getInputByLabel('Città',   root)?.value || '';
          const zip    = getInputByLabel('CAP',     root)?.value || '';
          const street = getInputByLabel('Via',     root)?.value || '';
          const number = getInputByLabel('Civico',  root)?.value || '';
          const cf     = (getInputByLabel('Codice fiscale', root)?.value || '').toUpperCase();
          const birth  = getInputByLabel('Data di nascita', root)?.value || '';
          const gender = getInputByLabel('Sesso', root)?.value || '';

          const codeEl = getInputByLabel('Codice casa', root);
          if (!codeEl) return;

          const ok = region && city && zip && street && number && cf && birth && gender;
          if (!ok) { setReactValue(codeEl, ''); return; }

          const cfCheck = validateCF(cf, birth, gender);
          if (!cfCheck.valid) { setReactValue(codeEl, ''); return; }

          const code = buildHouseCode({ region, city, zip, street, number, owner_cf: cf });
          if (codeEl.value !== code) setReactValue(codeEl, code);
        }

        // ================== COLLEGAMENTO EVENTI PER-RIGA ==================
        function wireRow(root){
          // maschera e lock
          attachBirthMask(root);
          lockCodeField(root);

          const region = getInputByLabel('Regione', root);
          const city   = getInputByLabel('Città',   root);
          const street = getInputByLabel('Via',     root);
          const num    = getInputByLabel('Civico',  root);
          const zip    = getInputByLabel('CAP',     root);
          const cf     = getInputByLabel('Codice fiscale', root);
          const gender = getInputByLabel('Sesso', root);

          // Autocomplete Città (per-riga)
          attachAutocomplete(
            city,
            ()=>({ type:'city', region: region ? region.value : '' }),
            (val)=>{ setReactValue(city, val); updateCodeForRow(root); }
          );

          // Autocomplete Via (dipende dalla città della stessa riga)
          attachAutocomplete(
            street,
            ()=>({ type:'street', city: city ? city.value : '' }),
            (val)=>{ setReactValue(street, val); updateCodeForRow(root); }
          );

          // Ogni campo rilevante aggiorna il codice di questa riga
          [[region,'change'],[city,'input'],[street,'input'],[num,'input'],[zip,'input'],[cf,'input'],[gender,'change']].forEach(([el,ev])=>{
            if (el) el.addEventListener(ev, ()=> updateCodeForRow(root));
          });

          // primo calcolo
          updateCodeForRow(root);
        }

        // ================== SCOPERTA AUTOMATICA DELLE RIGHE ==================
        function wireAllRows(){
          // Ogni "riga" è un blocco che contiene un "Codice casa"
          const labels=[...document.querySelectorAll('label')].filter(l=>l.textContent && l.textContent.includes('Codice casa'));
          labels.forEach(lab=>{
            const root = findRowRoot(lab);
            if (root && !root._bbWired) {
              root._bbWired = true;
              wireRow(root);
            }
          });
        }

        // Hook Decap
        CMS.registerEventListener({ name:'preSave',   handler:()=>{ wireAllRows(); } });
        CMS.registerEventListener({ name:'prePublish', handler:({entry,collection})=>{
          if(!collection||collection.get('name')!=='houses') return;
          wireAllRows();
          const items = entry.get('data')?.get?.('items') || [];
          for (let i=0;i<items.size;i++){
            const it=items.get(i);
            const code=String(it.get('code')||'');
            if(!code){ alert("Codice casa mancante alla riga "+(i+1)+"."); throw new Error("code mancante"); }
            if(!code.startsWith(PREFIX+'-')){ alert("Codice casa non valido alla riga "+(i+1)); throw new Error("code invalido"); }
          }
        }});

        // Observer: Decap monta i campi in asincrono
        const obs = new MutationObserver(()=>{ requestAnimationFrame(()=>{ wireAllRows(); }); });
        obs.observe(document.body, { childList:true, subtree:true });

        document.addEventListener('DOMContentLoaded', ()=>{ wireAllRows(); });

        // Chiudi pannelli autocomplete cliccando fuori
        document.addEventListener('click', (e)=>{
          document.querySelectorAll('.bb-ac-panel').forEach(p=>{
            if (!p.contains(e.target) && !(e.target && e.target.matches('input'))) p.style.display='none';
          });
        });
      })();
    </script>
  </body>
</html>
